using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor.Experimental.SceneManagement;
#endif

namespace SplineMesh {
    public class RoadMeshTiling : MonoBehaviour {
        private GameObject generated;
        private Spline spline = null;
        private bool toUpdate = false;

        [SerializeField]
        private bool road;

        private int curveIndex = 0;

        [Tooltip("Mesh to bend along the spline.")]
        public Mesh mesh;
        [Tooltip("Material to apply on the bent mesh.")]
        public Material material;
        [Tooltip("Physic material to apply on the bent mesh.")]
        public PhysicMaterial physicMaterial;
        [Tooltip("Translation to apply on the mesh before bending it.")]
        public Vector3 translation;
        [Tooltip("Rotation to apply on the mesh before bending it.")]
        public Vector3 rotation;
        [Tooltip("Scale to apply on the mesh before bending it.")]
        public Vector3 scale = Vector3.one;

        [Tooltip("If true, a mesh collider will be generated.")]
        public bool generateCollider = true;

        [Tooltip("If true, the mesh will be bent on play mode. If false, the bent mesh will be kept from the editor mode, allowing lighting baking.")]
        public bool updateInPlayMode;

        [Tooltip("If true, a mesh will be placed on each curve of the spline. If false, a single mesh will be placed for the whole spline.")]
        public bool curveSpace = false;

        [Tooltip("The mode to use to fill the choosen interval with the bent mesh.")]
        public MeshBender.FillingMode mode = MeshBender.FillingMode.StretchToInterval;

        private RoadBiomeConfig previousBiome = null;


        public void Begin() {
            // tip : if you name all generated content in the same way, you can easily find all of it
            // at once in the scene view, with a single search.
            string generatedName = "generated by " + GetType().Name;
            var generatedTranform = transform.Find(generatedName);
            generated = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject);

            spline = GetComponentInParent<Spline>();
            //spline.NodeListChanged += (s, e) => toUpdate = true;
            spline.NodeListChanged += (s, e) => CreateMeshes();

            toUpdate = true;
        }

        private void OnValidate() {
            if (spline == null) return;
            toUpdate = true;
        }


        private Dictionary<CubicBezierCurve, Material> materials = new Dictionary<CubicBezierCurve, Material>();
        private Dictionary<CubicBezierCurve, float> heights = new Dictionary<CubicBezierCurve, float>();

        float y = 0f;
        public void CreateMeshes() {
            /*if (previousBiome == null) {
                previousBiome = BiomeManager.main.CurrentBiome;
            }
            if (previousBiome != BiomeManager.main.CurrentBiome) {
                y -=0.1f;
                previousBiome = BiomeManager.main.CurrentBiome;
            }*/
#if UNITY_EDITOR
            // we don't update if we are in prefab mode
            if (PrefabStageUtility.GetCurrentPrefabStage() != null) return;
#endif
            var used = new List<GameObject>();
            if (curveSpace) {
                int index = 0;
                foreach (var curve in spline.curves) {
                    var go = FindOrCreate("segment " + index + " mesh");
                    go.GetComponent<MeshBender>().SetInterval(curve);
                    go.GetComponent<MeshCollider>().enabled = generateCollider;
                    if (road) {
                        if (!materials.ContainsKey(curve)) {
                            materials[curve] = BiomeManager.main.CurrentBiome.RoadMaterial;
                        }
                        go.GetComponent<MeshRenderer>().material = materials[curve];
                    } else {
                        if (!materials.ContainsKey(curve)) {
                            materials[curve] = BiomeManager.main.CurrentBiome.GroundMaterial;
                        }
                        go.GetComponent<MeshRenderer>().material = materials[curve];
                    }

                    if (!road) {
                        if (!heights.ContainsKey(curve)) {
                            y -= 0.001f;
                            heights[curve] = y;
                        }
                        go.transform.position = new Vector3(go.transform.position.x, go.transform.position.y + heights[curve], go.transform.position.z);
                    }
                    go.GetComponent<MeshCollider>().material = physicMaterial;
                    used.Add(go);
                    index += 1;
                }
                curveIndex = index;
            } else {
                var go = FindOrCreate("segment 1 mesh");
                go.GetComponent<MeshBender>().SetInterval(spline, 0);
                go.GetComponent<MeshCollider>().enabled = generateCollider;
                used.Add(go);
            }

            // we destroy the unused objects. This is classic pooling to recycle game objects.
            foreach (var go in generated.transform
                .Cast<Transform>()
                .Select(child => child.gameObject).Except(used).ToList()) {
                UOUtility.Destroy(go);
            }
        }

        private GameObject FindOrCreate(string name) {
            var childTransform = generated.transform.Find(name);
            GameObject res;
            if (childTransform == null) {
                res = UOUtility.Create(name,
                    generated,
                    typeof(MeshFilter),
                    typeof(MeshRenderer),
                    typeof(MeshBender),
                    typeof(MeshCollider));
                res.isStatic = !updateInPlayMode;
            } else {
                res = childTransform.gameObject;
            }

            MeshBender mb = res.GetComponent<MeshBender>();
            mb.Source = SourceMesh.Build(mesh)
                .Translate(translation)
                .Rotate(Quaternion.Euler(rotation))
                .Scale(scale);
            mb.Mode = mode;
            return res;
        }
    }
}
